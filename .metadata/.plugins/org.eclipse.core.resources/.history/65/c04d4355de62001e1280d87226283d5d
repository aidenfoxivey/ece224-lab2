#include <stdint.h>
#include <stdio.h>

#include "altera_avalon_pio_regs.h"
#include "sys/alt_irq.h"
#include "system.h"

#define ENABLE_REG_OFFSET 0
#define BUSY_REG_OFFSET 1
#define PERIOD_REG_OFFSET 2
#define PULSE_WIDTH_REG_OFFSET 3
#define AVERAGE_LATENCY_REG_OFFSET 4
#define MISSED_REG_OFFSET 5
#define MULTI_REG_OFFSET 6

void enable_egm(int period);
void disable_egm();
void print_statistics(int period, int tasks_run);
static void response_interrupt(void *context, alt_u32 id);
int background();
void tight_polling();

volatile int triggered = 0;

int main() {
	// run background function to warm it up
	background();

	// 0 -> interrupts, 1 -> polling
	int interrupts_or_polling = IORD(SWITCH_PIO_BASE, 0);
	if (interrupts_or_polling == 0) {
		printf("Interrupt mode selected.\n");
	} else {
		printf("Tight polling mode selected.\n");
	}

	printf("Please, press PB0 to continue.\n");

	/* wait until PB0 is pressed to start program */
	int button = IORD(BUTTON_PIO_BASE,0);
	while(button != 14) {
		button = IORD(BUTTON_PIO_BASE,0);
	}

	/* print CSV header to stdout */
	printf("Period,Pulse_Width,BG_Tasks,Latency,Missed,Multiple\n");

	/* register IRQ for stimulus in interrupt controller */
	alt_irq_register(STIMULUS_IN_IRQ, (void*)0, response_interrupt);

	for (int period = 2; period <= 5000; period += 2) {
		enable_egm(period);

		int background_count = 0;

				/* busy bit is enabled */
		while (IORD(EGM_BASE, BUSY_REG_OFFSET) == 1) {
			/* triggered is set in our stimulus_in interrupt */
			if (triggered == 1) {
				IOWR(RESPONSE_OUT_BASE, 0, 0x1);
				IOWR(RESPONSE_OUT_BASE, 0, 0x0);
				triggered = 0;
			}

			background();
			background_count++;
		}

		print_statistics(period, background_count);

		/* disable the EGM */
		IOWR(EGM_BASE, ENABLE_REG_OFFSET, 0);
	}

	return 0;
}

void print_statistics(int period, int tasks_run) {
	int pulse_width = period / 2;
	int latency = IORD(EGM_BASE, 4);
	int missed = IORD(EGM_BASE, 5);
	int multiple = IORD(EGM_BASE, 6);
	printf("%d,%d,%d,%d,%d,%d\n", period, pulse_width, tasks_run, latency, missed, multiple);
}

void enable_egm(int period) {
  int pulse_width = period / 2;

  // Configure EGM period and pulse width
  IOWR(EGM_BASE, PERIOD_REG_OFFSET, period);
  IOWR(EGM_BASE, PULSE_WIDTH_REG_OFFSET, pulse_width);

  // Enable EGM
  IOWR(EGM_BASE, ENABLE_REG_OFFSET, 1);
}

static void response_interrupt(void *context, alt_u32 id) {
	triggered = 1;
	IOWR(STIMULUS_IN_BASE, 3, 0x0);
}

int background() {
	int j;
	int x = 0;
	int grainsize = 4;
	int g_taskProcessed = 0;

	for (j=0; j < grainsize; j++) {
		g_taskProcessed++;
	}

	return x;
}

//void tight_polling() {
//	int firstRun = 1;
//    int background_count = 0;
//
//     /* while busy bit is running */
//    while (IORD(EGM_BASE, BUSY_REG_OFFSET) == 1) {
//    	int characterization_count = 0;
//
//         // time the case for one cycle
//         while(IORD(STIMULUS_IN_BASE, 0) == 0 && firstRun == 1) {
//        	 background();
//             characterization_count++;
//             firstRun = 0;
//             continue;
//         }
//
//         for (int i = characterization_count; i >= 0; --i) {
//        	 background();
//             ++background_count;
//         }
//
//         if (IORD(STIMULUS_IN_BASE, 0) == 1) {
//        	 IOWR(RESPONSE_OUT_BASE, 0, 1);
//        	 IOWR(RESPONSE_OUT_BASE, 0, 0);
//         }
//    }
//}

