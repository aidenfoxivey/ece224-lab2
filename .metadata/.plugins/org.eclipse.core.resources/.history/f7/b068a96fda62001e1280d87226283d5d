#include <stdint.h>
#include <stdio.h>

#include "altera_avalon_pio_regs.h"
#include "sys/alt_irq.h"
#include "system.h"

#define ENABLE_REG_OFFSET 0
#define BUSY_REG_OFFSET 1
#define PERIOD_REG_OFFSET 2
#define PULSE_WIDTH_REG_OFFSET 3
#define AVERAGE_LATENCY_REG_OFFSET 4
#define MISSED_REG_OFFSET 5
#define MULTI_REG_OFFSET 6

void enable_egm(uint16_t period);
void disable_egm();
void print_statistics(int period, int tasks_run);
static void response_interrupt(void *context, alt_u32 id);
int background();

int main() {
	// run background function to warm it up
	background();

	// 0 -> interrupts, 1 -> polling
	uint8_t interrupts_or_polling = IORD(SWITCH_PIO_BASE, 0);
	if (interrupts_or_polling == 0) {
		printf("Interrupt mode selected.\n");
	} else {
		printf("Tight polling mode selected\n");
	}

	printf("Please, press PB0 to continue.\n");

	uint8_t button = IORD(BUTTON_PIO_BASE,0);

	while(button != 14) {
		button = IORD(BUTTON_PIO_BASE,0);
	}

	printf("Period,Pulse_Width,BG_Tasks Run,Latency,Missed,Multiple\n");

	alt_irq_register(STIMULUS_IN_IRQ, (void*)0, response_interrupt);

	for (uint64_t period = 2; period <= 5000; period += 2) {
		enable_egm(period);
		uint64_t background_count = 0;

		while (IORD(EGM_BASE, BUSY_REG_OFFSET) == 1) {
			background();
			background_count++;
		}

		print_statistics(period, background_count);
		disable_egm();
	}

	return 0;
}

void print_statistics(int period, int tasks_run) {
	int pulse_width = period / 2;
	int latency = IORD(EGM_BASE, AVERAGE_LATENCY_REG_OFFSET);
	int missed = IORD(EGM_BASE, MISSED_REG_OFFSET);
	int multiple = IORD(EGM_BASE, MULTI_REG_OFFSET);
	printf("%d,%d,%d,%d,%d,%d\n", period, pulse_width, tasks_run, latency, missed, multiple);
}

void enable_egm(uint16_t period) {
  uint16_t pulse_width = period / 2;

  // Configure EGM period and pulse width
  IOWR(EGM_BASE, PERIOD_REG_OFFSET, period);
  IOWR(EGM_BASE, PULSE_WIDTH_REG_OFFSET, pulse_width);

  // Enable EGM
  IOWR(EGM_BASE, ENABLE_REG_OFFSET, 1);
}

void disable_egm() { IOWR(EGM_BASE, ENABLE_REG_OFFSET, 0); }

static void response_interrupt(void *context, alt_u32 id) {
	IOWR(RESPONSE_OUT_BASE, 0, 0x1);
	IOWR(RESPONSE_OUT_BASE, 0, 0x0);
	IOWR(STIMULUS_IN_BASE, 3, 0x0);
}

int background() {
	int j;
	int x = 0;
	int grainsize = 4;
	int g_taskProcessed = 0;

	for (j=0; j < grainsize; j++) {
		g_taskProcessed++;
	}

	return x;
}

void tight_polling() {
	int firstRun = 1;
    int background_count = 0;

     /* while busy bit is running */
    while (IORD(EGM_BASE, BUSY_REG_OFFSET) == 1) {
    	int characterization_count = 0;

         // time the case for one cycle
         while(IORD(STIMULUS_IN_BASE, 0) == 0 && firstRun == 1) {
        	 background();
             characterization_count++;
             firstRun = 0;
             continue;
         }

         for (int i = characterization_count; i >= 0; --i) {
        	 background();
             ++background_count;
         }

         if (IORD(STIMULUS_IN_BASE, 0) == 1) {
        	 IOWR(RESPONSE_OUT_BASE, 0, 1);
        	 IOWR(RESPONSE_OUT_BASE, 0, 0);
         }
    }
}

